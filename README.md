# CrossSolver
A solver for the Rubik's Cube‘s cross problem
__魔方求解\-十字求解器__

# 枚举法\-深度Ⅰ

注：本文的十字处理用的是白底，所谓底棱就是白色底面的棱块也就是白棱，底面就是底棱的白色面，可能会用到一些魔方中简单的术语，放心对理解不会产生太大影响

__本人有2年魔方经验，三阶速拧百次平均13s__

__对魔方稍有理解，酝酿许久才成此文__

__作此文，是为了__

__博采众议，并在修改后于暑假用c\+\+实现这个十字求解器__

__今后可能会在b站用视频讲解__

__文中如有涉及较难理解的地方请指出，我会尽力修改并加上图片__

### 前言

无论是层先法还是CFOP，十字处理是必不可少的环节，可能对于30秒开外的人而言十字处理的好坏并无大碍，因为这确实只是数十步解法中，2~3秒的一瞬，提升十字处理并不能在整体速度上获得明显进步。但对于20秒或是12秒以内的人而言，十字处理水平就尤为重要了，因为0.5-1.5秒和2~4秒的差距与12秒这个小分母一比比值急剧增大。这是9秒和12秒的区别。作为一个卡在15s瓶颈一年多的菜鸟，意识到在其他环节难以得到明显的进步，因此打算摸索摸索十字处理技术。不玩魔方的大佬会问，速度不行练手速去啊！

为了解决这问题，首先我们对“手速”这个概念有个正确的认识。

记得苏格拉底灵魂三问中有一问是“我是谁”。

__手速是什么？__

用专业点的词语表述就是**tps** （time per second），这里的time译为“次，回”，类似于“four times a week”，tps 翻译过来差不多就是每秒多少步。

初中物理学过，时间=路程/速度，手速（tps）可理解为速度，t=s/v中的路程s可类比为__还原步骤__，于是我们得到了一个公式：还原时间=还原步骤/tps。

即使如此，问题还没解决。根据公式可知，提升手速的确可以取得进步，但手速是有上限的，在实战中由4tps提升到5tps之难难于上青天啊！各位可以亲自尝试一下。

综上所述，提升手速比较困难，那么从优化原步骤入手，即优化解法，因此，我决定做一个十字求解器。

### 正文

考虑到读者中有一部分不是魔友，这里先科普一下，理论上，任何一种打乱，十字都可在≤8步内处理完。为了尽量减少还原步骤，我们还原十字时，凭借自身经验往往能做出“__连带__”这一技颇具技巧的操作。所谓连带，大致可理解为还原一个底棱的同时顺带着另一个底棱移动，从而节省步骤。

补充说明一下，这里说的十字处理完成的结果是底面四棱归位且与周围四格中心相对应。

刚刚提到，包括最终调整，理论上任何一种打乱，十字都能在≤8步内还原，若用傻瓜式的“__黄色小花法__”，先在顶部拼出白色小花，然后对应中心依次归位。的确，这种方法很容易就能实现，但黄色小花法所消耗的最多步骤为：2步x4棱\+2步x4棱=16步，与8步大相径庭。舍去。

黄色小花法问题出在要拼出白色小花，这一步实在是多余。既然如此，假如我们让计算机将四个底棱按绿→橙→蓝→红的顺序依次还原，每个底棱的还原过程由

__取出＋校位＋还原__

三步组成，那么此法最多消耗的步数为3x4＝12步，仅管依旧＞8步，但已明显优于“黄色小花法”，我们称此法为“__排队解决法__”

不难看出排队解决法问题出在，四个底棱原顺序比较硬式，非得按绿橙蓝红的顺序。我们知道，在4个底棱一个都没归位时，也就是打乱状态下，任意一块都可还原到底面的任意一个棱块位置，因为第一个底棱没有相对位置的束缚\(对应周围四格中心的任务可以在最后通过1步D层来完成\)，因此，上一法中提到的取出＋校位＋还原三步中第一个底棱可以跳过“校位”这一步，其余3个底棱依旧按排队解决法中的取出＋校位＋还原3步走。那么最终这个方法最多消耗2＋3x3＝11步，还是＜8步，但相较“排队解决法”，我们又更进了一步。

不过，细心的读者可能发现，上一个办法实际上并没有解决任何问题。上一法似乎解决了第一个底棱不需校位的问题，但由于第一次处理底棱时候不考虑对应中心位置，导致最终仍然需要一步来调整，而且后3个底棱排队解决的问题仍未得以解决，所以上一法实际最多步骤还是2＋3x3＋1＝12步，没有改善。

长达两个多星期思考的中，类此的失败不计其数，但每一次失败都是一次进步，至少给我们提供了不少思路。这次失败的过程中，我们发现了排队解决法棱块环原顺序上的死板。最重要的是，我们想到了，在第一块底棱的选择上动手脚，如果整套算法的本质不变，始终为：

__棱1（取\-归）→棱2（取\-校\-归）→棱3（取\-校\-归）→棱4（取\-校\-归）→D层一步调整。__

那么优化解法的路径就在于消步，也就是实操中的“连带”，一次连带可以助下一个底棱跳过取、校中的1~2个步骤，只要连带量足够，就能从12步跃进至8步。那么问题来了，L1~L4中，一定会出现连带吗？难道就没有一种打乱无法进行任何连带吗？我可以肯定地说，所有打乱都可以连带！此前我们已得出每块底棱环原至多经历__取\-校\-归__三步，在这三步中，至少会涉及3个面的转动，精确到棱就是9个棱的转动。长方体共12棱，9个棱必动\(称为动棱\)，3个棱必闲\(称为闲棱\)，9动棱中至少有1个待归位的棱，如果除此之外的动棱中无一是底棱，那么剩余3个闲棱必定全是底棱，这三个闲棱如中有2个在底面，若这2个棱可没有一个是底面\(就是白面\)朝下的，那么无论如何，中间的底棱一定能跳过“取”步。这种3个闲棱全是底楼且落下面两个全不是底面朝下的情况只有在第一个底棱还未环原的状态才下会出现，因此3闲棱中中间的底棱又必能跳过“校”步，所以这种3闲棱全为底棱的极端情况也必然会有一个底棱跳过“取校”二步，而在这个中间底棱归位时又必然连带一个原本在底面的底棱，从而再省一步，而被连带的底棱还原过程中可能会连带原来9动棱中唯一的一个底棱，即使不连带那个底棱，那么原来3个闲棱中剩下没动过的底棱在还原过程中必然会连带那个动底棱，从而再省一步。

综上，即使是9动棱中仅有一个底棱的极端情况，仍然能至少省下4步。如果9动棱中，有≥2个动底棱存在其中一个被还原时肯定会连带另一个，如果这次连带能达到消步的目的那更好，如果不能，那另一块底棱在被连带之前就已能消步，而这≥2个底棱环原后100%会连带其它底棱。也就是说，包括那个极端情况在内，所有底棱环原所省步数之和必然>=4，那么总数最多是8。至此，我们证明了最多环原步骤这个事实。

以上所有过程都是我在进两个星期中总结的\(不包括过去两年的魔方经验\)，尽管进行了不少的计算和实验，但仍然可能会有所偏差，欢迎各位大佬指正。如果合理，我会第一时间进行改正。

但对于机器而言，我们的算法本质还是

__L1（取\-归）→L2（取\-校\-归）→L3（取\-校\-归）→L4（取\-校\-归）→D层一步调整__

仅管理论上必会产生连带消步，但机器在执行算法时貌似无法意识到这点。在阅读下文前，为方便理解，建议再浏览一遍上一段。

所以我们要想办法让机器 “意识”到这一点。好消息是，我想到一种让机器“意识”到消步的办法；坏消息是，这个意识的过程并不智能，也就是伪意识。这主要是受限于我目前初三浅陋的数学知识。

为了解决一道选择题，除了直接求出答案这一高效的办法，还能用排除法。前文在讲排队解决法的时候，我们规定了计算机要按绿橙蓝红顺序还原。假设最优解\(也就是能消步最多的路径\)是按红橙绿蓝的顺序还原，那么我们预设的绿橙红蓝必然不能达到最优，即使我们用红橙蓝绿，那和最优解还是在绿蓝顺序上引了起的差异。

所以！我们可以发现，解决问题的突破扣在于还原顺序！

乾坤未定，你我皆是黑马，面对未知的世界，我们只有通过尝试来探明乾坤。同理，为了找到最优解或者说最优还原顺序，我们要让机算机：

__穷举__

换而言之，用专业点的话说就是

__枚举法__

让机算机将所有还原顺序都尝试一遍从而找出最优解。下图为枚举的总量\(G＝绿，O＝橙，R＝红，B＝蓝）
![Alt text]([https://github.com/weiman152/StarsView/blob/master/ScreenShots/1.png](https://github.com/Doujiamu/CrossSolver/blob/main/img/map.png))  

共24种可选顺序，将这些顺序作为参数依次代入算法，记下每条路径的步数，找出最短的路径，输出。这样的话十字求解就可以完成，同时三层的深度可以捕获所有连带情况。

至此，十字求解枚举法\-深度Ⅰ的思路完结了，没错，只是思路，自由时间对于初三考生而言是极其珍贵的，这两周的空闲时间有很大一部分都在思考一种可以在我能力范围内实现的十字求解法。到成文为止，暂时未落实到程序中，文中提到的“黄白小花”和“排队解决法”是我思考过程中比较有代表性的角度，还有很多想法未经自己深入思考就被否认了。有些不切实际，像导入公式库求解；有些不在我能力范围内，比如说建立类似人工智能的神经网络来学习（这个对我而言实属荒谬）。

创新，或者具体到个人思想上的创新；是有趣而痛苦的。苦在探所从未涉足过方面时的艰辛，乐在毛塞顿开时的成就感和苦尽甘来的满足感。\(这可能是全文唯一表述得能让人看懂的一段了，我语文真的不好抱歉\)

最后，也是最重要的，对能从头到尾看到现在的读者，表示诚挚的感谢和敬意。

